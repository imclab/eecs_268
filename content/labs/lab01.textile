---
title:  Lab 01
layout: default

filter:
  - erb
  - textile

order: 01
---

h1. Lab 01

h2. Doxygen

p((. *Read Appendix F*

Also some information over required comments in the helpful notes section of my website.

h3. Required comments

From the class text book, pages 44 - 45

Commenting required in each source code file:

1. Initial comment at the *top of each file* 

* File name (@file)
* Statement of purpose
* Author (@author)
* Date (@date)
* File version number (@version) -- optional

2. Comment for each *class* 

* Name of class and its header file (@class) -- optional
* Statement of purpose

3. Comment for each *method or function*

* Statement of purpose
* Description of each argument in the argument list (@param)
* Preconditions (@pre)
* Postconditions (@post)
* Exceptions thrown (@throw)
* Return value (@return)

4. Comments in the body of each function elaborating on important / difficult logic

h2. Passing Command Line Arguments

A very common requirement of an application is that it accepts parameters passed to it on execution.  In other words, many programs need some information during 'startup' to get going.

In C++, this can be accomplished using a special argument list for your main function.  So your main function will be modified to look like this:

<pre>
  <code>
    int main(int argc, char* argv[])
    {
      //...
    }
  </code>
</pre>

Here we now give two arguments to main: argc and argv.  

*argc* is an integer that indicates the number of arguments passed to your program.  Make note that in C++ the _name_ of your program counts as your first parameter.  So argc will always be at least 1.

*argv* is an array of character pointers, each of which points to one of the arguments that was passed in.  Because your program's name counts as the first parameter, @argv[0]@ will always point to that character array.

So, for example, if you had an application called @tester@ and you executed this application using the following command:

<pre>
  <code>
    $ tester hey you guys
		
  </code>
</pre>

the variable @argc@ would automatically be populated with the value 4, as there are 3 parameters given, plus the name of the application.  Likewise @argv@ would be an array of size 4.  @argv[0] = "tester"@, @argv[1] = "hey"@, @argv[2] = "you"@, @argv[3] = "guys"@.

h3. Command Line Arguments in DDD

In order to debug applications that require command line arguments, you will need to indicate to ddd how to run your application.  This can be done in the following steps:

* open your application in ddd as usual: @ddd app_name@
* Click on the _Program_ drop-down menu
* Click on the option _Run..._
* A new pop-up window will appear
* Place your cursor in the bottom text box of this window
* Type in the arguments you'd like to pass to the application at runtime
** Remember: Use tab auto-completion

h2. Character Sequences

Good tutorial at "the c++ reference site":http://www.cplusplus.com/doc/tutorial/ntcs.html

h3. File Streams

We will be making use of *ofstreams* and *ifstreams* for reading and writing to files.

To create a i/ofstream with a particular name, simply pass its name as a parameter to the file stream constructor:

<pre><code>
  ifstream in("input.txt");
  
</code></pre>

We can use the formatted read / write methods: @>>@ and @<<@.  For formatted input, the stream will be read up until the next white space.  This white space can be a space, a tab character, or a newline character:

<pre>
  <code>
    char command[100];
    ifstream in('input.txt');
    in >> command;  // reads in first word of input.txt to the command variable
  </code>
</pre>

To utilize the ifstream and ofstream classes, we must include the *fstream* library.

More information can be found on the "reference website":http://www.cplusplus.com/reference/iostream/
