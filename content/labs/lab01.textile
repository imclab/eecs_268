---
title:  Lab 01
layout: default

filter:
  - erb
  - textile

order: 01
---

h1. Lab 01

h2. Doxygen

p((. *Read Appendix F*

Also some information over required comments in the helpful notes section of my website.

h3. Required comments

From the class text book, pages 44 - 45

Commenting required in each source code file:

1. Initial comment at the *top of each file* 

* File name (@file)
* Statement of purpose
* Author (@author)
* Date (@date)
* File version number (@version) -- optional

2. Comment for each *class* 

* Name of class and its header file (@class) -- optional
* Statement of purpose

3. Comment for each *method or function*

* Statement of purpose
* Description of each argument in the argument list (@param)
* Preconditions (@pre)
* Postconditions (@post)
* Exceptions thrown (@throw)
* Return value (@return)

4. Comments in the body of each function elaborating on important / difficult logic

h2. typedef

Format of a typedef statement:

p((. typedef _DataType_ _AliasName_;

_DataType_ can be any of the built-in data types in C++. So for example, it could be *integer* or *double*.

_AliasName_ is what you want the new name to be.

h3. typedef examples

* @typedef double LargeNumber;@
** here @LargeNumber@ could now be used to declare a variable of type @double@.
* @typedef double* PointerDouble;@
** now @PointerDouble@ can be used to declare a pointer to a @double@.
* @typedef int IntArray[15];@
** @IntArray@ now can be used to create an array of @integers@ of size fifteen.

Note the format of the typedef calls matches normal variable declaration.  That is to say, without the @typedef@ component each of these examples would create variables of the @DataType@ type.  However, instead of variable creation, with the @typedef@ statement, new types are created instead.  These new types can then be used as the prefix to the declaration of new variables. 

"more information about typedef":http://www.functionx.com/cpp/keywords/typedef.htm

h2. Matrix Determinant 

Given a 2x2 matrix *M* with the values:

p((. [m~0,0~,  m~0,1~]

p((. [m<sub>1,0</sub>,  m<sub>1,1</sub>] 

The determinant of *M* is given as:

p((. m<sub>0,0</sub> x m<sub>1,1</sub> - m<sub>1,0</sub> x m<sub>0,1</sub>

_Example:_ So given a matrix :

p((. [5 , 6]

p((. [2 , 3]

The determinant would be:

p((. 5 x 3 - 2 x 6 = 15 - 12 = 3

For a square matrix larger than 2x2, the determinant can be found using the "expansion using minors and cofactors" method.  

h3. Definitions

*minor*

A minor, N~i,j~ is the sub-matrix of the original matrix M with the ith row and jth column removed.

*cofactor* 

A cofactor for any element is either the minor or the opposite of the minor, depending on where the element is in the original determinant. If the row and column of the element add up to be an even number, then the cofactor is the same as the minor. If the row and column of the element add up to be an odd number, then the cofactor is the opposite of the minor.

This is a confusing definition, but the formula is not difficult as we will see below.

h3. Expansion Using Minors and Cofactors

1. Pick any row or column in the matrix. It does not matter which row or which column you use, the answer will be the same for any row. 

2. Multiply every element in that row or column by its cofactor and add. The result is the determinant.

A simpler formula for this algorithm is:

p((. det(M) = summation [ (-1)^i+j^ m~ij~ x N~i,j~ ]

In this setup, the cofactors are taken care of using the (-1)^i+j^ which multiplies the minor( N~i,j~) by one or negative one, depending on the row and column.

When the minors associated with each element are larger than 2x2, then they must be expanded in turn until they are reduced to 2x2 matrices, from which a determinant can be computed.

_Example_ If the original matrix was of size 4x4, then this first expansion would create 4 minors, each of size 3x3.  Each 3x3 matrix would then need to be expanded to 3 2x2 matrices.  From these 2x2 matrices, a determinant is computed.

h2. Matrix Inverse

With a real number, A, the inverse of A, A^-1^ is the number such that A x A^-1^ = 1

With a square matrix A, the inverse of A, A^-1^ is the matrix such that A x A^-1^ = identity matrix. (all 0's except for 1's on the main diagonal)

For a matrix to have an inverse, its determinant cannot be 0.

h2. Other Notes

* "Review ostream":http://www.cplusplus.com/reference/iostream/ostream/
** Look at formatting options when outputting numbers.
* Input file to read from should be passed in as a *command line argument*.


h2. Online Matrix Math

check your determinant and inverse calculations "here":http://www.bluebit.gr/matrix-calculator/


h2. Passing Command Line Arguments

A very common requirement of an application is that it accepts parameters passed to it on execution.  In other words, many programs need some information during 'startup' to get going.

In C++, this can be accomplished using a special argument list for your main function.  So your main function will be modified to look like this:

<pre>
  <code>
    int main(int argc, char* argv[])
    {
      //...
    }
  </code>
</pre>

Here we now give two arguments to main: argc and argv.  

*argc* is an integer that indicates the number of arguments passed to your program.  Make note that in C++ the _name_ of your program counts as your first parameter.  So argc will always be at least 1.

*argv* is an array of character pointers, each of which points to one of the arguments that was passed in.  Because your program's name counts as the first parameter, @argv[0]@ will always point to that character array.

So, for example, if you had an application called @tester@ and you executed this application using the following command:

<pre>
  <code>
    $ tester hey you guys
		
  </code>
</pre>

the variable @argc@ would automatically be populated with the value 4, as there are 3 parameters given, plus the name of the application.  Likewise @argv@ would be an array of size 4.  @argv[0] = "tester"@, @argv[1] = "hey"@, @argv[2] = "you"@, @argv[3] = "guys"@.

h3. Command Line Arguments in DDD

In order to debug applications that require command line arguments, you will need to indicate to ddd how to run your application.  This can be done in the following steps:

* open your application in ddd as usual: @ddd app_name@
* Click on the _Program_ drop-down menu
* Click on the option _Run..._
* A new pop-up window will appear
* Place your cursor in the bottom text box of this window
* Type in the arguments you'd like to pass to the application at runtime
** Remember: Use tab auto-completion

h2. Character Sequences

Good tutorial at "the c++ reference site":http://www.cplusplus.com/doc/tutorial/ntcs.html

h3. File Streams

We will be making use of *ofstreams* and *ifstreams* for reading and writing to files.

To create a i/ofstream with a particular name, simply pass its name as a parameter to the file stream constructor:

<pre><code>
  ifstream in("input.txt");
  
</code></pre>

We can use the formatted read / write methods: @>>@ and @<<@.  For formatted input, the stream will be read up until the next white space.  This white space can be a space, a tab character, or a newline character:

<pre>
  <code>
    char command[100];
    ifstream in('input.txt');
    in >> command;  // reads in first word of input.txt to the command variable
  </code>
</pre>

To utilize the ifstream and ofstream classes, we must include the *fstream* library.

More information can be found on the "reference website":http://www.cplusplus.com/reference/iostream/
