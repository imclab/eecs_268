---
title:  Lab 02
layout: default

filter:
  - erb
  - textile
  
order: 02
---

h1. Lab 02

h2. Classes

Each class you create will consist of two files: a *header* file (@.h@) and *implementation* file (@.cpp@). 

h3. Header Files:

h4. Layout:

<pre>
<code>
  #ifndef _UNIQUENAME_
  #define _UNIQUENAME_
  //include statements
  class ClassName
  {
    public:
       //public methods
       
    private:
       //private methods
  };
  #endif
</code>
</pre>

h4. Description:

The header file contains the definition of the class.  That is declarations of its functions as well as data it stores.  

*#ifndef / #define / #endif*

These are compiler pre-processors to prevent the header file from being included more than once in the linked program.  This is done because C++ cannot handle header files being included more than once.  

Essentially, it checks to see if the pre-processor macro named @_UNIQUENAME_@ has already been defined, i.e. the header file has already been included.  If not, then it defines it and brings in the rest of the code until the @#endif@ statement.  If it has already been defined, then that indicates that this header file has already been included, and thus, the compiler skips down to the @#endif@ statement without including it again.

Make sure the two @_UNIQUENAME_@ statements are the same.

*include statements*

Here you will include the other libraries / header files needed in the class.  Do *not* put 'using' statements, such as @using namespace std;@ into a header file, if at all possible.  So in a header file, if you are using a string type variable, you will want to declare it as std::string.  This applies to all functions and objects in the C++ standard library, including cout, cin, and the various streams. "More information":http://www.cplusplus.com/reference/ on the std library  

*default constructor*

This is a constructor with no arguments or one that gives all the arguments default values.  These default values should be defined in the header file and not in the implementation file.  Usually, this constructor is used to initialize private variables to standard values.

*Note:* Don't forget to place a semicolon (@;@) after the closing bracket of the class definition! 

Also, using const at the end of a function declaration indicates that the function cannot alter the classes data members.  


h3. Implementation Files:

h4. Layout:

<pre>
  <code>
    #include HeaderFileName.h
    //using statements
    
    returnType ClassName::methodName
    {
      //method implementation 
    }
  </code>
</pre>

h4. Example:

<pre>
  <code>
    #include "Matrix.h"
    using namespace std;

    double Matrix::determinant( ) const
    {
      //...
    }
  </code>
</pre>

h4. Description:

The format is fairly straightforward, as long as you remember to include the "@Matrix::@" part. 

Inside a function definition, you can access the functions directly without the use of any prefix. So for example, inside the inverse function, the determinant function of the Matrix class could be called using @determinant()@ instead of @Matrix::determinant();@.

h2. Operator Overloading

All operator overloading means is that we are redefining methods to work with new data types.  The 'overloading' indicates that after redefining this method, the same method name can be called to execute multiple actual methods, based on the object it is being called on, and the input parameters of the call.

h3. Simple Example:

the '+' operator, when used with integers, performs arithmetic addition:
<pre>
	<code>
		7 + 3 //returns 10
		7.+(3) //returns 10
		
		// However, when used with strings, 
		// the '+' operator performs concatenation:
		
		"Ben " + "Murphy" //returns "Ben Murphy"
		"Ben ".+("Murphy")
	</code>
</pre>


So this is a form of polymorphism : The ability of objects belonging to different types to respond to method calls of the same name, each one according to an appropriate type-specific behavior.

h3. C++ Syntax

For these arithmetic operators, we must use a special syntax to indicate to the system that we want to define a method in terms of a symbol (+,-,=, etc).

This syntax is adheres to the following format:

p((. @<return_type> operator<symbol_to_overload>@

Example:  If we wanted to redefine the == inside of our Fraction class from lab 1, we could use something like:

p((. @bool operator==(const Fraction& rhs) const;@

Where the first @const@ inside the input arguments indicates that we can't change the value of rhs while the @const@ at the end indicates that no variables of the Fraction class will be modified. 


h2. Detecting End of File

Two ways I have found to work for this project.

h3. Simpler &#38; Cleaner way

<pre>
  <code>
    ifstream inputFile (argv[1]);
    
    while(!inputFile.eof())
    {
      //... 
    }
  </code>
</pre>

This seems to work for the sample file, and so will probably work fine for this project.

*Problems with this method:*

* Inconsistent between different compilers

* No good definition as to what the end of file actually is

* Might not work on various input files depending on what program created them

* According to "This Guy":http://allenh.ecs.fullerton.edu/ modern compilers don't set the eof in the file stream, making this method useless.

h3. More Confusing, Less Elegant but perhaps better way

<pre>
  <code>
    ifstream inputFile (argv[1]);
    string command;

    while(1)
    {
      inputFile >> command;

      if(inputFile.fail())   
      {					 
          break;
      }
      
      // ...
    }
  </code>
</pre>




So, This method breaks out of the while loop when the fail method of the inputFile returns true.  It returns true if an input operation doesn't succeed for any reason.  This is usually because of an illegal character or the end of file.

 
