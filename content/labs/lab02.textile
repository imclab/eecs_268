---
title:  Lab 02
layout: default

filter:
  - erb
  - textile
  
order: 02
---

h1. Lab 02

h2. Classes

Each class you create will consist of two files: a *header* file (@.h@) and *implementation* file (@.cpp@). 

h3. Header Files:

h4. Layout:

<pre>
<code>
  #ifndef _UNIQUENAME_
  #define _UNIQUENAME_
  //include statements
  class ClassName
  {
    public:
       //public methods
       
    private:
       //private methods
  };
  #endif
</code>
</pre>

h4. Description:

The header file contains the definition of the class.  That is declarations of its functions as well as data it stores.  

*#ifndef / #define / #endif*

These are compiler pre-processors to prevent the header file from being included more than once in the linked program.  This is done because C++ cannot handle header files being included more than once.  

Essentially, it checks to see if the pre-processor macro named @_UNIQUENAME_@ has already been defined, i.e. the header file has already been included.  If not, then it defines it and brings in the rest of the code until the @#endif@ statement.  If it has already been defined, then that indicates that this header file has already been included, and thus, the compiler skips down to the @#endif@ statement without including it again.

Make sure the two @_UNIQUENAME_@ statements are the same.

*include statements*

Here you will include the other libraries / header files needed in the class.  Do *not* put 'using' statements, such as @using namespace std;@ into a header file, if at all possible.  So in a header file, if you are using a string type variable, you will want to declare it as std::string.  This applies to all functions and objects in the C++ standard library, including cout, cin, and the various streams. "More information":http://www.cplusplus.com/reference/ on the std library  

*default constructor*

This is a constructor with no arguments or one that gives all the arguments default values.  These default values should be defined in the header file and not in the implementation file.  Usually, this constructor is used to initialize private variables to standard values.

*Note:* Don't forget to place a semicolon (@;@) after the closing bracket of the class definition! 

Also, using const at the end of a function declaration indicates that the function cannot alter the classes data members.  


h3. Implementation Files:

h4. Layout:

<pre>
  <code>
    #include HeaderFileName.h
    //using statements
    
    returnType ClassName::methodName
    {
      //method implementation 
    }
  </code>
</pre>

h4. Example:

<pre>
  <code>
    #include "Matrix.h"
    using namespace std;

    double Matrix::determinant( ) const
    {
      //...
    }
  </code>
</pre>

h4. Description:

The format is fairly straightforward, as long as you remember to include the "@Matrix::@" part. 

Inside a function definition, you can access the functions directly without the use of any prefix. So for example, inside the inverse function, the determinant function of the Matrix class could be called using @determinant()@ instead of @Matrix::determinant();@.

h2. Operator Overloading

"Giving an operator more than one meaning"

Using the '+' symbol to add an object to the end of an array, instead of the default arithmetic.  

Gives you the ability to redefine commonly used symbols to function how you want them to for your classes and allow for more intuitive code.

h3. Syntax

create a function with the format:
<code>
    <returnType> operator <symbol> <arguments> 
</code>

An *example* would be:
<code>
    Matrix operator*(const Matrix& rhs) const;
</code>

This redefines the "*" operator so that you are able to use it to multiply matrices using:
<code>
    result_matrix = matrix1 * matrix2 
</code>

Also good for redefining '==', '>=', etc.  With these you could base equality on an internal (private) variable and then return a boolean value based on this comparison. 

h2. Detecting End of File

Two ways I have found to work for this project.

h3. Simpler &#38; Cleaner way

<pre>
  <code>
    ifstream inputFile (argv[1]);
    
    while(!inputFile.eof())
    {
      //... 
    }
  </code>
</pre>

This seems to work for the sample file, and so will probably work fine for this project.

*Problems with this method:*

* Inconsistent between different compilers

* No good definition as to what the end of file actually is

* Might not work on various input files depending on what program created them

* According to "This Guy":http://allenh.ecs.fullerton.edu/ modern compilers don't set the eof in the file stream, making this method useless.

h3. More Confusing, Less Elegant but perhaps better way

<pre>
  <code>
    ifstream inputFile (argv[1]);
    string command;

    while(1)
    {
      inputFile >> command;

      if(inputFile.fail())   
      {					 
          break;
      }
      
      // ...
    }
  </code>
</pre>




So, This method breaks out of the while loop when the fail method of the inputFile returns true.  It returns true if an input operation doesn't succeed for any reason.  This is usually because of an illegal character or the end of file.

 
