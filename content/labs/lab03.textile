---
title:  Lab 03
layout: default

filter:
  - erb
  - textile

order: 03
---

h1. Lab 03

h2. Pointers

Remember, pointers store the address of a value stored somewhere else on the computer memory. Pointers point to strings / numbers / objects, but aren't actually any of those things.  

h3. Syntax

Here are the common usages of pointers.

h4. Creation

<pre><code>
    int *p;      //-- creates a pointer that can point to integers
    
    string *s;   //-- creates a pointer that can only point to string objects
    
</code></pre>

h4. Assigning an Address

<pre>
  <code>
    int x = 7;   //-- x is just a normal integer
    
    p = &x;      //-- indicates that the pointer p now 
                 //   contains the memory address of the variable x.
                 //   So p points to x.
  </code>
</pre>

h4. Assigning Values using Pointers

<pre>
  <code>
    *p = 2;      //-- this changes the value stored in the address held by p. 
                 //   Meaning *p and x will change.     
  </code>
</pre>

h4. Using Multiple Pointers

<pre>
  <code>
    int *q;		   //-- q is another integer pointer.
    
    q = p;       //-- q and p point to the same thing.  
                 //   Meaning, p and q now contain the same memory address.
  </code>
</pre>

"See my example":http://people.eecs.ku.edu/~jvalland/files/lab03/pointers.cpp (mostly from the book) for more experience with pointers.


h2. Notes on insert method

<pre>
<code>
  ListNode *newPtr = new ListNode;
</code>
</pre>
Here we are dynamically creating a new ListNode object that will hold the string newItem.  So newPtr is a ListNode pointer which points to (contains the address of) this new ListNode.

<pre>
<code>
  newPtr->item = newItem;
</code>
</pre>
Here we assign the item variable held inside the ListNode object pointed to by newPtr.  This is special syntax needed when dealing with objects or structures referenced to by pointers instead of actual variables. 

If this were a statically allocated ListNode, the equivalent call would be @l_node1.item = newItem;@, where @l_node1@ is an object of type ListNode.  However, since it is dynamically allocated, we can't use the *[object]* _._ *[method]* syntax, and instead must use the *[pointer]* _->_ *[method]* syntax.

<pre>
  <code>
    newPtr->next = head;
    
    head = newPtr;
  </code>
</pre>

Here we are dealing with the 'head' pointer.  Remember, head is not an actual node, but just another node pointer, just like the 'next' pointer in each ListNode.

<pre>
<code>
  try {} catch (bad_alloc e) {}
</code>
</pre>

Good example of multiple layers of exception handling.  The 'new' function could fail if we run out of memory (although very unlikely for this lab).  This shows the method 'insert' catching the possible exception that can occur (@bad_alloc@) and then throwing its own exception as a way of dealing with it (ListException).  This allows our main function to only deal with list exceptions.  It also abstracts the way we are holding the list from how it is accessed.  	

h2. Detecting End of File

Two ways I have found to work for this project.

h3. Simpler &#38; Cleaner way

<pre>
  <code>
    ifstream inputFile (argv[1]);
    
    while(!inputFile.eof())
    {
      //... 
    }
  </code>
</pre>

This seems to work for the sample file, and so will probably work fine for this project.

*Problems with this method:*

* Inconsistent between different compilers

* No good definition as to what the end of file actually is

* Might not work on various input files depending on what program created them

* According to "This Guy":http://allenh.ecs.fullerton.edu/ modern compilers don't set the eof in the file stream, making this method useless.

h3. More Confusing, Less Elegant but perhaps better way

<pre>
  <code>
    ifstream inputFile (argv[1]);
    string command;

    while(1)
    {
      inputFile >> command;

      if(inputFile.fail())   
      {					 
          break;
      }
      
      // ...
    }
  </code>
</pre>




So, This method breaks out of the while loop when the fail method of the inputFile returns true.  It returns true if an input operation doesn't succeed for any reason.  This is usually because of an illegal character or the end of file.


"Here is the paper":http://people.eecs.ku.edu/~jvalland/files/lab03/cpp_files.pdf from which I found this method
