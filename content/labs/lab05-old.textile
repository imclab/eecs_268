---
title:  Lab 05
layout: default

filter:
  - erb
  - textile
  
order: 05
---

h1. Lab 05

h2. Inheritance

h3. Inheritance Syntax

To indicate a class is a subclass of another:

<pre>
  <code>
    #include "Customer.h"

    class FrequentCustomer : public Customer
  </code>
</pre>

Here we see that FrequentCustomer is a subclass of Customer. FrequentCustomer inherits all the methods and attributes of Customer (except constructor and destructor).

h3. Pointers to Subclasses

We can have pointers of type base class point to the subclass type.

<pre>
  <code>
    Customer c1;
    EliteCustomer ec1;
    Customer* cp1 = &c1;
    // here's the pointer to a subclass
    Customer* cp2 = &ec1;
  </code>
</pre>

The main problem with this is that cp1 and cp2 are still just pointers to objects of type Customer, and so you can only call methods defined in the Customer class. 
 
<pre>
  <code>
    cp2->getName(); // fine if its defined in Customer
    cp2->getEliteStatus(); // compile error
  </code>
</pre>
 
What's worse is that even if a method is reimplemented in the subclass, attempting to call that method will result in a call to the original implementation of the method
 
<pre><code>
    cp2->talk() // actually calls the talk method of the Customer class.
    
</code></pre>

h3. Virtual Methods

So the solution for this problem is to declare the method as a virtual method in the base class.  This indicates to the compiler that a method could be overridden in the derived class, so check there first for an implementation.

<pre>
  <code>
    class Customer
    {
      virtual std::string talk();
      // note the virtual keyword.
    };
    
    class EliteCustomer : public Customer
    {
      virtual std::string talk();
      // overrides the talk() in Customer.
    }
    
    // now the call to talk
    cp2->talk();
    // calls the correct talk method
  </code>
</pre>

Useful "link for more information":http://www.cplusplus.com/doc/tutorial/polymorphism.html.

h3. Storing base class pointers in data structures

This means you should be storing pointers to Customer in your Queue and Stack because they can point to instances of EliteCustomer and FrequentCustomer, so you'll need to implement only one version of both types.

<pre>
  <code>
    class Stack
    {
    	typedef Customer* StackItemType;
    	//...
    	private:
    	StackItemType* stack;
  	};
  	
  	class Queue
    {
    	typedef Customer* QueueItemType;

    	struct ListNode
    	{
    		QueueItemType item;
    		ListNode* next;
    	};
    };
  </code>
</pre>

h2. Useful tips

h3. A second virtual member

To facilitate the requirements of the output printCurrentCustomer() method, which requires the level of the customer to be output, add another virtual method to the Customer class:

<pre><code>
  class Customer
  {
    //...
    virtual std::string getCustomerDescription();
  }
  
</code></pre>

This can be used to store the class of the customer, and then can be overridden in the derived classes.

h3. Exception Handling

Probably the easiest/cleanest way to deal with problems in this lab.  Create a simple exception class, as in the previous lab, and then throw an exception when a problem is encountered.  Catch this exception in main and output the error message, then continue reading in commands.

Remember, you should be dealing with the exceptions thrown by the stack and queue code as well.

h3. Dynamic Allocation

You do not know how many Customers / EliteCustomers / FrequentCustomers you will be reading in.  So these all should be allocated dynamically, each time a new one is needed.  And again, you should be storing Customer pointers in your Stack and Queue.

h3. getCurrentCustomer() Method

You'll be finding the current customer in multiple places (when finishing, when printing, etc) -- encapsulate your process of getting the current customer in a method, so you only have to implement it once! 