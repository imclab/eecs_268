---
title:  Lab 06
layout: default

filter:
  - erb
  - textile

order: 06
---

h1. Lab 06

h2. Random Number Generation

Simple random numbers can be created with the %rand()% function.  Because we are comparing multiple sorting algorithms, it makes sense to test them on the same data.  So, we want the randomly generated array used in one sorting method to be the same randomly generated array used in another.  This can be done by 'seeding' the random number generator, so that using this seed, the generator will create the same random numbers in the same order.  Seeding the random number function can be done with the %srand()% function.  You *only want to seed once*.  That is to say you don't want to seed each time you create a new random number, but just once before the number creation process starts.

Another issue we need to deal with in this lab is constraining our random numbers to a certain range of possible numbers. In the lab description, we are given that the random numbers should be less than or equal to 100 and greater than or equal to 0.  This can be done using the modulus operator as shown in the example code below.  According to various c++ forums, random number generator can be of very low quality depending on the compiler you are using.  Thus, this might result in predictable patterns if you are using a small enough maximum size.  With our case, 100 should be large enough to get a decent random mixture.

Another, more complicated method is also given below, which is supposedly immune to the possible pattern generation of the simple mod method.  This method divides the randomly generated number by the maximum possible value for randomly generated numbers, creating a number from 0 to 1.  This is then multiplied by the number of integers between the min and max number and added to the minimum number.  The code is slightly more complicated than the description I give, but thats the short of it.

h3. Random Numbers: Example code

h4. Simple Modulus Method

<pre>
  <code>
    srand(123);   //seed the random number generator
    int highest = 100;
    int lowest = 0;
    int randomNumber = lowest + rand()%((highest-lowest)+1);
  </code>
</pre>

h4. More Complicated Method

<pre>
  <code>
    srand(123);   //seed the random number generator
    int highest = 100;
    int lowest = 0;
    int range = (highest-lowest)+1;
    int randomNumber = lowest+int(range*(rand()/(RAND_MAX+1.0)));
  </code>
</pre>

Probably either one of these will work for our purposes, people just seem to lean towards using the second one.

h2. Timing 

Timing code execution can be done in C++ using the %ctime% library.  

This example is taken directly from "This Site":http://www.juniata.edu/faculty/kruse/cs315/cs315Timing.htm

h3. Timing: Example code

<pre>
  <code>
    #include <ctime>;

    clock_t start,finish;
    double time;
    start = clock();

    //sort something

    finish = clock();
    
    time = (double(finish)-double(start))/CLOCKS_PER_SEC;
  </code>
</pre>

Here, the @clock()@ function returns the number of clock ticks elapsed since the program was launched.  So we first take the clock ticks before the sort algorithm.  Then we take the clock ticks again after the code we are interested in has completed.  Subtracting these two numbers gives us the number of ticks that the algorithm took to complete.  %CLOCKS_PER_SEC% holds the conversion rate from clock ticks to seconds.  So we divide by this number to get the total seconds taken.  

You could also leave the number in clock ticks - as long as you perform all your experiments on the same machine.  

Other applications running, and other issues might affect the performance of these algorithms.  This is why it would probably be in your best interest to keep the conditions of your computer as static as possible when running these tests. 

You can make sure it compiles on the EECS computers (and runs), but do the actual tests on your computer, where there will most likely be more controllable conditions. 

Remember, only include the sorting in your timing tests.  *Don't include the array creation in your timing*.

h2. Other Notes

The file %SelectionSort.cpp% has the typedef statement used in all the other sorting algorithms, so in your main file, include it before any of the others. 

Use the _strcomp() == 0_ method if you want to leave your input arguments as c strings.

The Selection sort file includes two functions 'indexOfLargest' and 'swap' that need to be declared before the 'selectionSort' function.

The Merge sort has a maximum integer size that you can modify to be the maximum value needed for these experiments.

Make sure you *delete* the array at the end of the program.

h2. Automation of Testing

A shell script could be used to automatically call these tests and append their outputs to a file. 

Shell scripts usually have the file extension '.sh'. 

A shell script starts with a line indicating the interpreter program that will execute the file.  In our case, we would like the default shell to run the commands so our first line would be:

<pre>
<code>
  #!/bin/sh
</code>
</pre>

Then we can add lines to the file, each one will be executed as if they were typed in from the command prompt.

Ex:

<pre>
<code>
  ./lab06 250 random selection >> select_out.txt
</code>
</pre>

Note the use of the '>>' character.  This *redirects* the output of the command to a file.  The double arrow indicates that the output will be *appended* to the file, instead of overwriting the contents of the output file.

So you could make a line like this for everyone of your needed commands and have the output be added to one or more files. (You would probably want that output to include some information about the current test being executed, so you don't get the times confused.)

To make this shell script executable, navigate to the directory holding it in the terminal and add executable rights to the file:

<pre>
<code>
  chmod +x lab06.sh
</code>
</pre>

then you can run it from the command line like a normal executable program.

Shell scripts can be considerably more complex (loops, if/then, etc), but this should be sufficient for the application.